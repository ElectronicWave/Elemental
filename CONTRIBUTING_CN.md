# 为 Elemental 贡献代码

感谢你考虑为 **Elemental** 做出贡献。

Elemental 被设计为一个**基础性工具集**：像元素一样可组合、对下游用户透明，并且尽量减少隐含假设。本文件用于阐明贡献时应遵循的原则，以确保项目在长期内保持可维护性、可预期性以及对开发者友好。

---

## 核心理念

在开始编码之前，请确保你的设计与以下理念保持一致。

### 1. 开发者友好优先

* API 应当 **直观、可发现、且不易被误用**。
* 优先选择显式设计，而不是“魔法行为”。
* 新的贡献者应当能够理解设计存在的**原因**，而不仅仅是使用方式。

### 2. 用户透明

* Elemental 不应给用户带来“意外行为”。
* 错误必须是可见且可解释的。
* 所有副作用（IO、状态变更、网络请求等）必须是显式的。

### 3. 组合性优先

Elemental 的组件应当像元素一样：

* 职责单一
* 可自由组合
* 不依赖隐藏的全局状态
* 模块之间不存在隐式耦合

如果一个功能无法被干净地组合，它大概率不适合进入核心层。

---

## API 设计规范

### 清晰且可预测的 API

* 函数名应描述**做什么**，而不是**怎么做**。
* 避免通过布尔值或标志位控制多种不同行为。
* 优先使用：

```rust
fn load_config(path: &Path) -> Result<Config>
```

而不是：

```rust
fn load(path: &Path, strict: bool, cache: bool) -> Config
```

### 用类型而不是约定表达语义

* 尽可能通过类型系统表达约束与不变量。
* 避免使用“魔法字符串”或松散类型参数。

### 向后兼容性

* 公共 API 被视为稳定契约。
* 破坏性变更必须满足：

  * 明确说明
  * 有充分理由
  * 有文档记录

如果无法保持向后兼容，应当提供迁移方案。

---

## 错误处理

### 库代码中禁止使用 `panic!`

* **不要**使用 `panic!` 处理可恢复错误。
* 优先使用 `anyhow::Result<T>` 或明确定义的错误类型。

```rust
use anyhow::Result;

fn parse(input: &str) -> Result<Ast> {
    // ...
}
```

### 可以忽略错误的场景

* 若错误确实不影响核心行为：

  * 必须记录日志
  * 必须说明为何忽略是安全的

静默失败是不可接受的。

---

## 代码风格

### 格式化

* 所有 Rust 代码必须通过 `rustfmt` 格式化。
* 不要依赖编辑器私有的格式化规则。

```sh
cargo fmt
```

### 可读性优先于技巧性

* 优先选择直观、易读的实现方式。
* 避免为了“巧妙”而牺牲可维护性。
* 先保证清晰，再考虑优化。

### 小而聚焦的改动

* 一个 PR 只做一件逻辑上的事情。
* 不要在同一个 PR 中混合重构与行为变更。

---

## 依赖管理

### 最小依赖原则

* 每一个依赖都会增加维护成本。
* 在合理情况下优先使用标准库。
* 避免仅为微小功能引入新依赖。

### 依赖排序

只要修改了 `Cargo.toml`，请确保依赖顺序已整理：

```sh
cargo install cargo-sort
cargo sort
```

这有助于保持 diff 干净、可读。

---

## 文档

### 代码级文档

* 所有公共 API **必须**包含 rustdoc 注释。
* 至少说明：

  * 功能作用
  * 错误条件
  * 重要不变量或约束

### 设计文档

* 非平凡的架构决策应当被记录。
* 如果你在设计时花了很多心思，未来的贡献者也会如此。

---

## 测试

* 新功能必须包含测试。
* Bug 修复必须包含回归测试。
* 优先选择确定性测试，避免依赖时间或环境的不稳定测试。

如果某段代码很难测试，这通常意味着设计需要被重新审视。

---

## Pull Request 指南

在提交 PR 之前，请确认：

* [ ] 项目可以正常构建，测试通过
* [ ] 已执行代码格式化（`cargo fmt`）
* [ ] 已整理依赖顺序（`cargo sort`）
* [ ] 公共 API 已编写文档
* [ ] 变更符合 Elemental 的组合性设计理念

### PR 描述要求

请说明：

* **解决了什么问题**
* **为什么选择这种实现方式**
* **权衡了哪些方案**

---

## 不属于 Elemental Core 的内容

为了保持 Elemental 的基础性定位，以下内容不应进入核心层：

* 强主观的业务逻辑
* 硬编码的运行环境假设
* 改变语义的功能开关
* 类框架式的生命周期管理

这些内容应当构建在 **Elemental 之上**，而不是之内。

---

## 最后说明

Elemental 追求的是“好的无聊”：

* 可预测
* 稳定
* 易于组合

如果你的贡献让系统变得更简单、更清晰、更容易与其他组件组合，那么它很可能是一个合适的改动。

感谢你为构建一个可靠的基础所做出的努力。
